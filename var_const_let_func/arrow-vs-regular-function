Arrow functions are shorter. Arrow functions are not always better
1. =>
Regular Function → has its own this
const user = {
  name: "Sam",
  greet: function () {
    console.log(this.name);
  }
};

user.greet(); // Sam
2. =>
Arrow Function → inherits this from parent
const user = {
  name: "Sam",
  greet: () => {
    console.log(this.name);
  }
};

user.greet(); // undefined
Rule:
Never use arrow functions as object methods.

3. =>
this Inside Callbacks
Regular function (loses this)
function Timer() {
  this.seconds = 0;

  setTimeout(function () {
    console.log(this.seconds); // undefined
  }, 1000);
}

Arrow function (keeps this)
function Timer() {
  this.seconds = 0;

  setTimeout(() => {
    console.log(this.seconds); // 0
  }, 1000);
}

4. =>
arguments Object
function sum() {
  console.log(arguments);
}
sum(1, 2, 3);
..............
Arrow Function ❌
const sum = () => {
  console.log(arguments); // ERROR
};

5. =>
Constructors (new keyword)
function Person(name) {
  this.name = name;
}
const p = new Person("Alex");
..............
Arrow Function ❌
const Person = (name) => {
  this.name = name;
};
// ❌ Cannot be used with `new`

6. =>
When to Use Each
Use Arrow Functions When:

Callbacks (map, filter, setTimeout)

Short utility functions

When you want to keep this
numbers.map(n => n * 2);
.......
Use Regular Functions When:
Object methods
Constructors
You need arguments
You need your own this
...........
Arrow functions:
Can omit return if there’s only one expression
Are shorter and more readable for small functions

7. =>
Common Mistakes
❌ Using arrow functions as object methods
❌ Using arrow functions as constructors
❌ Expecting arrow functions to have arguments
❌ Forgetting arrow functions inherit this

Arrow functions are for behavior, regular functions are for objects.
